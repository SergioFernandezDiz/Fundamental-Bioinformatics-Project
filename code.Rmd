---
title: "Bioinformatics Project"
author: "Sergio Fernandez - Alessandro Mecchia - Paolo Nicolet"
date: "`r Sys.Date()`"
output:
  html_notebook:
    toc: true
    toc_depth: 2
---

# Imports and packages

```{r}
BiocManager::install("recount3")
install.packages("tidyverse")
install.packages("pheatmap")
```

```{r}
library(recount3)
library(tidyr)
library(dplyr)
library(ggplot2)
library(plotly)
library(stringr)
library(edgeR)
library(pheatmap)
```

# 1. Project Introduction

**da completare**

# 2. Dataset Selection

```{r}
# List of available projects
projects <- available_projects()
projects

```

```{r}
# Filter by GTEx (normal tissues)
gtex_projects <- subset(projects, file_source == "gtex")

# Explore metadata
gtex_projects
```

```{r}

proj_info_pancreas <- subset(
    gtex_projects,
    project == "BRAIN" & project_type == "data_sources"
)

# Connet to GTEx project
rse_gene_BRAIN <- create_rse(proj_info_pancreas)
rse_gene_BRAIN
```

```{r}
colnames(colData(rse_gene_BRAIN))
```

```{r}

# Filter by TCGA (the cancer genome atlas)
tcga_projects <- subset(projects, file_source== "tcga")

# Explore metadata
tcga_projects
```

```{r}

proj_info_gbm <- subset(
  tcga_projects,
  project == "GBM" & project_type == "data_sources"
)

rse_gene_tcga <- create_rse(proj_info_gbm, type = "gene")

metadata_tcga <- colData(rse_gene_tcga)
all_cols <- colnames(metadata_tcga)

diagnosis_cols <- grep("^tcga\\.gdc_cases\\.diagnoses", all_cols, value = TRUE)
print(diagnosis_cols)

demo_cols <- grep("^tcga\\.gdc_cases\\.demographic", all_cols, value = TRUE)
print(demo_cols)

```

```{r}
rse_gene_tcga
```

## 2.1. Dataset Reduction 

**spiegare il problema che siccome di dati normali abbiamo quasi 3000 e solo 200 circa di dati con tumore dobbiamo fare una selezione per cercare di eliminare questo bias** 

```{r}
md_gtex <- as.data.frame(colData(rse_gene_BRAIN))
md_tcga <- as.data.frame(colData(rse_gene_tcga))
```


```{r}
gtex_counts <- as.data.frame(table(md_gtex$gtex.smtsd))
colnames(gtex_counts) <- c("Region", "Count")

ggplot(gtex_counts, aes(x = reorder(Region, -Count), y = Count)) +
  geom_bar(stat = "identity", fill = "steelblue") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "GTEx Sample Distribution by Brain Region",
       x = "Region", 
       y = "Number of Samples")
```

```{r}
tcga_site_counts <- as.data.frame(table(md_tcga$tcga.gdc_cases.project.primary_site))
colnames(tcga_site_counts) <- c("Region", "Count")

ggplot(tcga_site_counts, aes(x = reorder(Region, -Count), y = Count)) +
  geom_bar(stat = "identity", fill = "firebrick") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "TCGA Sample Distribution by Anatomical Region",
       x = "Primary Site", 
       y = "Number of Samples")

```
The initial dataset was highly unbalanced, with over 3,000 healthy samples (GTEx) compared to approximately 180 tumor samples (TCGA). To ensure a statistically sound comparison and prevent memory issues during processing, we have filtered the GTEx group to include only samples from the Brain - Cortex. This region is the most biologically relevant for comparison with Glioblastoma (GBM). This reduction to roughly 286 healthy samples creates a more balanced experimental design, which optimizes the statistical power of the differential expression analysis and allows for clearer visualization of sample clusters.

```{r}
rse_gene_BRAIN <- rse_gene_BRAIN[, rse_gene_BRAIN$gtex.smtsd == "Brain - Cortex"]
```


# 3. Data Exploration

## 3.1. Age distribution

```{r}
age_gtex <- md_gtex$gtex.age
head(age_gtex)

age_tcga <- md_tcga$tcga.gdc_cases.diagnoses.age_at_diagnosis
head(age_tcga)
```

```{r}
gtex_bins   <- c(20,30,40,50,60,70,80, Inf)
gtex_labels <- c("20-29","30-39","40-49","50-59","60-69","70-79","80+")

df_age_perc <- bind_rows(
  data.frame(
    age_bin = factor(md_gtex$gtex.age, levels = gtex_labels),
    dataset = "GTEx"
  ),
  data.frame(
    age = as.numeric(md_tcga$tcga.gdc_cases.diagnoses.age_at_diagnosis) / 365.25,
    dataset = "TCGA"
  ) %>%
    mutate(age_bin = cut(age, breaks = gtex_bins, labels = gtex_labels, right = FALSE))
) %>%
  filter(!is.na(age_bin)) %>%
  count(dataset, age_bin) %>%
  group_by(dataset) %>%
  mutate(percent = n / sum(n) * 100) %>%
  ungroup()


```

```{r}

p <- ggplot(
  df_age_perc,
  aes(x = age_bin, y = percent, fill = dataset)
) +
  geom_col(position = "dodge") +
  labs(
    x = "Age range (years)",
    y = "Percentage of samples",
    title = "Normalized age distribution: GTEx vs TCGA"
  ) +
theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(p)

```

## 3.2. Sex Distribution

```{r}
sex_gtex <- md_gtex$gtex.sex %>%
  recode(
    `1` = "Male",
    `2` = "Female"
  )

sex_tcga <- md_tcga$tcga.gdc_cases.demographic.gender
```

```{r}
df_sex <- bind_rows(
  data.frame(
    sex = sex_gtex,
    dataset = "GTEx"
  ),
  data.frame(
    sex = sex_tcga,
    dataset = "TCGA"
  )
) %>%
  filter(!is.na(sex)) %>%
  mutate(sex = str_to_title(sex)) %>% 
  count(dataset, sex) %>%
  group_by(dataset) %>%
  mutate(percent = n / sum(n) * 100) %>%
  ungroup()

```

```{r}
p_sex <- ggplot(
  df_sex,
  aes(x = sex, y = percent, fill = dataset)
) +
  geom_col(position = "dodge") +
  labs(
    x = "Sex",
    y = "Percentage of samples",
    title = "Sex distribution: GTEx vs TCGA"
  ) +
  theme_minimal()

ggplotly(p_sex)

```

## 3.3. RNA Quality

```{r}

df_qc_long <- bind_rows(
  md_gtex %>%
    transmute(
      dataset = "GTEx",
      avgq = recount_seq_qc.avgq,
      errq = recount_seq_qc.errq
    ),
  md_tcga %>%
    transmute(
      dataset = "TCGA",
      avgq = recount_seq_qc.avgq,
      errq = recount_seq_qc.errq
    )
) %>%
  pivot_longer(
    cols = c(avgq, errq),
    names_to = "metric",
    values_to = "value"
  ) %>%
  filter(!is.na(value))

```

```{r}
p_qc_facet <- ggplot(
  df_qc_long,
  aes(x = dataset, y = value, fill = dataset)
) +
  geom_boxplot(outlier.alpha = 0.3) +
  facet_wrap(~ metric, scales = "free_y",
             labeller = as_labeller(c(
               avgq = "Average base quality (avgq)",
               errq = "Base error rate (errq)"
             ))) +
  labs(
    x = "",
    y = "",
    title = "RNA-seq quality metrics comparison: GTEx vs TCGA"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold")
  )

ggplotly(p_qc_facet)

```

# 4. Different Gene Expression Analysis (Bulk RNA-seq)

```{r}
counts_gtex <- transform_counts(rse_gene_BRAIN)
counts_tcga <- transform_counts(rse_gene_tcga)

common_genes <- intersect(rownames(counts_gtex), rownames(counts_tcga))

counts_gtex2 <- counts_gtex[common_genes, ]
counts_tcga2 <- counts_tcga[common_genes, ]

count_matrix <- cbind(counts_gtex2, counts_tcga2)
```

```{r}
count_matrix <- as.data.frame(count_matrix)
head(count_matrix)
```

## 4.1. Quality Control

### 4.1.1. Normalization

**Counts Per Million (CPM)**

For a given gene *i* in sample *j*, the CPM is calculated as:

$$
\text{CPM}_{ij} = \left( \frac{\text{Raw count}_{ij}}{\sum_{k=1}^{N} \text{Raw count}_{kj}} \right) \times 10^6
$$

Where:

-   $\text{Raw count}_{ij}$: number of reads for gene *i* in sample *j*\
-   ${\sum_{k=1}^{N} \text{Raw count}_{kj}}$: total number of reads for all genes in sample *j*\
-   The multiplication by \$ 10\^6 \$ scales the expression to "per million" units

```{r cpm-filter}
# Obtain CPMs
CPMs <- cpm(count_matrix)
# Have a look at the output
CPMs <- as.data.frame(CPMs)
head(CPMs)

```

**Filtering lowly expressed genes**

Genes with very low counts across all libraries provide little evidence for differential expression and they interfere with some of the statistical approximations that are used later in the pipeline. They also add to the multiple testing burden when estimating false discovery rates, reducing power to detect differentially expressed genes. These genes should be filtered out prior to further analysis.

There are a few ways to filter out lowly expressed genes. When there are biological replicates in each group, in this case we have a sample size of 2 in each group, we favour filtering on a minimum counts per million threshold present in at least 2 samples. Two represents the smallest sample size for each group in our experiment. In this dataset, we choose to retain genes if they are expressed at a counts-per-million (CPM) above 0.5 in at least two samples.

We' ll use the cpm function from the edgeR library (M D Robinson, McCarthy, and Smyth 2010) to generate the CPM values and then filter. Note that by converting to CPMs we are normalising for the different sequencing depths for each sample.

```{r cpm-thresh}
# Which values in myCPM are greater than 0.5?
thresh <- CPMs > 0.3
# This produces a logical matrix with TRUEs and FALSEs
thresh <- as.data.frame(thresh)
head(thresh)
```

```{r cpm-keep}
# Summary of how many TRUEs there are in each row
table(rowSums(thresh))


# This filter removes genes that are only detected in one sample or not detected at all, ensuring that only genes with evidence of expression in multiple samples are kept for further analysis
keep <- rowSums(thresh) >= 2
# Subset the rows of countdata to keep the more highly expressed genes
counts.keep <- count_matrix[keep,]
dim(counts.keep)
```

As a general rule, a good threshold can be chosen by identifying the CPM that corresponds to a count of 10, which in this case is about 0.3. You should filter with CPMs rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples.

Another way in doing so is using the built in function `filterByExpr()` of the edgeR package, however to do so we would need more information such as the design of the study and the division in groups because the function is testing if a gene wil be statistically significant in function of the experiment setup.

```{r cpm-plot}
# Let's have a look and see whether our threshold of 0.5 does indeed correspond to a count of about 10-15 by Plotting the expression profile of the first sample (First column)
plot(CPMs[,1],count_matrix[,1],ylim=c(0,20),xlim=c(0,2))
abline(v=0.3)

```

```{r}
counts_filtered <- as.data.frame(counts.keep)
head(counts_filtered)
```

**Normalization for Composition Bias (TMM)**

While CPM normalization accounts for differences in sequencing depth (library size), it does not address **composition bias**. Composition bias occurs when a small number of highly expressed genes dominate the total pool of RNA in a library, artificially deflating the relative counts of all other genes.

We apply **TMM** normalization instead of **TPM** because:

-   **TPM** is for comparing different genes **within** one sample (it corrects for gene length).

-   **TMM** is for comparing the same gene **between** different samples (Healthy vs. Tumor). It corrects for **composition bias**, ensuring that a few highly expressed genes do not skew the results for the entire library.

```{r}
# Create DGEList object
dgeObj <- DGEList(counts = counts_filtered)
```

```{r}
# Calculate TMM normalization factors
dgeObj <- calcNormFactors(dgeObj, method = "TMM")
```


```{r}
# Check normalization factors (should be around 1)
head(dgeObj$samples)
```


### 4.1.2. Unsupervised Clustering

```{r}

# Calculate log2-CPM 
logcounts_all <- cpm(dgeObj, log = TRUE)
pca_input <- t(logcounts_all)

# Perform PCA 
pca_res <- prcomp(pca_input, scale. = TRUE)
pca_df <- as.data.frame(pca_res$x)

pca_df$Group <- c(rep("GTEx", ncol(counts_gtex2)), rep("TCGA", ncol(counts_tcga2)))

# Generate the PCA plot
ggplot(pca_df, aes(x = PC1, y = PC2, color = Group)) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  scale_color_manual(values = c("GTEx" = "blue", "TCGA" = "red")) +
  labs(title = "Unsupervised Clustering: PCA",
       subtitle = "Analysis based on the full set of filtered genes",
       x = paste0("PC1 (", round(100*summary(pca_res)$importance[2,1], 1), "%)"),
       y = paste0("PC2 (", round(100*summary(pca_res)$importance[2,2], 1), "%)"))

```
```{r}

pca_df$AvgQ <- c(md_gtex[colnames(counts_gtex2), ]$recount_seq_qc.avgq, 
                 md_tcga[colnames(counts_tcga2), ]$recount_seq_qc.avgq)
pca_df$AgeNumeric <- as.numeric(gsub("[^0-9]", "", pca_df$Age)) 

p <- plot_ly(pca_df, x = ~PC1, y = ~PC2, 
             symbol = ~Group,
             symbols = c('circle', 'x'),
             text = ~paste("Sample:", SampleID, "<br>Sex:", Sex, "<br>Age:", Age, "<br>AvgQ:", AvgQ),
             type = "scatter", mode = "markers",
             marker = list(size = 10, opacity = 0.8)) %>%
  layout(
    title = "PCA: Interactive Color Switching",
    xaxis = list(title = "PC1"),
    yaxis = list(title = "PC2"),
    updatemenus = list(
      list(
        x = 0.05,
        y = 1,
        xanchor = "left",
        yanchor = "top",
        buttons = list(
          list(method = "restyle",
               args = list("marker.color", list(ifelse(pca_df$Group == "GTEx", "blue", "red"))),
               label = "Color by Dataset"),
          
          list(method = "restyle",
               args = list("marker.color", list(ifelse(pca_df$Sex == "Male", "#1f77b4", "#e377c2"))),
               label = "Color by Sex"),
          
          list(method = "restyle",
               args = list("marker.color", list(pca_df$AgeNumeric),
                           "marker.colorscale", "Viridis",
                           "marker.showscale", TRUE),
               label = "Color by Age"),

          list(method = "restyle",
               args = list("marker.color", list(pca_df$AvgQ),
                           "marker.colorscale", "Plasma",
                           "marker.showscale", TRUE),
               label = "Color by RNA Quality")
        )
      )
    )
  )

p

```


## 4.2. DE Analysis

**Count the reads for any sample**

Here we visualize the library size for every sample

```{r}
idx_gtex <- 1:ncol(counts_gtex2)
idx_tcga <- (ncol(counts_gtex2) + 1):(ncol(counts_gtex2) + ncol(counts_tcga2))

lib_sizes_gtex <- dgeObj$samples$lib.size[idx_gtex]
names(lib_sizes_gtex) <- colnames(dgeObj)[idx_gtex]
low_10_gtex <- sort(lib_sizes_gtex)[1:10]

lib_sizes_tcga <- dgeObj$samples$lib.size[idx_tcga]
names(lib_sizes_tcga) <- colnames(dgeObj)[idx_tcga]
low_10_tcga <- sort(lib_sizes_tcga)[1:10]

low_20_total <- c(low_10_gtex, low_10_tcga)

par(mar = c(10, 4, 4, 2)) 
barplot(low_20_total / 1e6, 
        las = 2,
        ylab = "Library size (millions)", 
        main = "Bottom 10 Samples by Library Size (GTEx vs TCGA)",
        col = c(rep("blue", 10), rep("red", 10)),
        cex.names = 0.7) # Rimpicciolisce i nomi delle colonne per farli stare

legend("topleft", legend = c("GTEx (Lowest 10)", "TCGA (Lowest 10)"), 
       fill = c("blue", "red"), bty = "n")


```

***Plot the distribution of expression for sample***

```{r}
sample_means <- colMeans(CPMs)

idx_gtex <- 1:ncol(counts_gtex2)
idx_tcga <- (ncol(counts_gtex2) + 1):(ncol(counts_gtex2) + ncol(counts_tcga2))

low_10_gtex_names <- names(sort(sample_means[idx_gtex])[1:10])
low_10_tcga_names <- names(sort(sample_means[idx_tcga])[1:10])

logcounts <- cpm(count_matrix, log=TRUE)
sub_logcounts <- logcounts[, c(low_10_gtex_names, low_10_tcga_names)]
```

```{r}
par(mar = c(10, 4, 4, 2))
boxplot(sub_logcounts, 
        las = 2, 
        main = "Boxplot of Log2-CPMs (Bottom 10 Samples per Group)",
        ylab = "Log2 Counts per Million",
        col = c(rep("blue", 10), rep("red", 10)),
        names = c(paste0("GTEx_", 1:10), paste0("TCGA_", 1:10))) 

abline(h = median(logcounts), col = "darkgreen", lwd = 2, lty = 2)
legend("topright", legend = c("GTEx (Lowest Mean)", "TCGA (Lowest Mean)", "Global Median"), 
       fill = c("blue", "red", NA), border = c("black", "black", NA),
       lty = c(NA, NA, 2), col = c(NA, NA, "darkgreen"), bty = "n")
```
